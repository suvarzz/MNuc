y <- mx[i,]
points(x, y, col=col[i])
lo <- loess(mx[i,] ~ x)
lines(predict(lo(x=seq(min(x), max(x), by=length(x)*100))), col=col[i])
}
lo <- loess(mx[i,] ~ x=seq(min(x), max(x), by=length(x)*100)))
x <- c(1:ncol(mx))
plot(0,type='n',
axes=T,
ann=T,
ylim=ylim,
xlim=c(1, ncol(mx)),
main=feature_names[1])
for (i in 1:nrow(mx)) {
y <- mx[i,]
points(x, y, col=col[i])
lo <- loess(mx[i,] ~ x)
xl <- seq(min(x), max(x), length=length(x)*100)
lines(predict(lo, xl)), col=col[i])
}
plot(0,type='n',
axes=T,
ann=T,
ylim=ylim,
xlim=c(1, ncol(mx)),
main=feature_names[1])
for (i in 1:nrow(mx)) {
y <- mx[i,]
points(x, y, col=col[i])
lo <- loess(mx[i,] ~ x)
xl <- seq(min(x), max(x), length=length(x)*100)
lines(predict(lo, xl), col=col[i])
}
for (i in 1:nrow(mx)) {
y <- mx[i,]
points(x, y, col=col[i])
lo <- loess(mx[i,] ~ x)
xl <- seq(min(x), max(x), length=length(x)*100)
lines(predict(xl, lo), col=col[i])
}
for (i in 1:nrow(mx)) {
y <- mx[i,]
points(x, y, col=col[i])
lo <- loess(mx[i,] ~ x)
xl <- seq(min(x), max(x), length=length(x)*100)
lines(predict(xl, lo), col=col[i])
}
for (i in 1:nrow(mx)) {
y <- mx[i,]
points(x, y, col=col[i])
lo <- loess(mx[i,] ~ x)
xl <- seq(min(x), max(x), length=length(x)*100)
lines(predict(lo, xl), col=col[i])
}
plot(0,type='n',
axes=T,
ann=T,
ylim=ylim,
xlim=c(1, ncol(mx)),
main=feature_names[1])
plot(0,type='n',
axes=T,
ann=T,
ylim=ylim,
xlim=c(1, ncol(mx)),
main=feature_names[1])
for (i in 1:nrow(mx)) {
y <- mx[i,]
points(x, y, col=col[i])
lo <- loess(mx[i,] ~ x)
xl <- seq(min(x), max(x), length=1000)
lines(predict(lo, xl), col=col[i])
}
plot(0,type='n',
axes=T,
ann=T,
ylim=ylim,
xlim=c(1, ncol(mx)),
main=feature_names[1])
for (i in 1:nrow(mx)) {
y <- mx[i,]
points(x, y, col=col[i])
lo <- loess(x ~ mx[i,])
xl <- seq(min(x), max(x), length=1000)
lines(predict(lo, xl), col=col[i])
}
plot(0,type='n',
axes=T,
ann=T,
ylim=ylim,
xlim=c(1, ncol(mx)),
main=feature_names[1])
for (i in 1:nrow(mx)) {
y <- mx[i,]
points(x, y, col=col[i])
smoothingSpline = smooth.spline(x, y, spar=0.477)
#lo <- loess(x ~ mx[i,])
xl <- seq(min(x), max(x), length=1000)
lines(predict(smoothingSpline, xl), col=col[i])
}
for (i in 1:nrow(mx)) {
y <- mx[i,]
points(x, y, col=col[i])
smoothingSpline = smooth.spline(x, y, spar=0.1)
#lo <- loess(x ~ mx[i,])
xl <- seq(min(x), max(x), length=1000)
lines(predict(smoothingSpline, xl), col=col[i])
}
for (i in 1:nrow(mx)) {
y <- mx[i,]
points(x, y, col=col[i])
smoothingSpline = smooth.spline(x, y, spar=0.2)
xl <- seq(min(x), max(x), length=length(x)*10)
lines(predict(smoothingSpline, xl), col=col[i])
}
plot(0,type='n',
axes=T,
ann=T,
ylim=ylim,
xlim=c(1, ncol(mx)),
main=feature_names[1])
for (i in 1:nrow(mx)) {
y <- mx[i,]
points(x, y, col=col[i])
smoothingSpline = smooth.spline(x, y, spar=0.2)
xl <- seq(min(x), max(x), length=length(x)*10)
lines(predict(smoothingSpline, xl), col=col[i])
}
smoothingSpline = smooth.spline(x, y, spar=0.1)
plot(0,type='n',
axes=T,
ann=T,
ylim=ylim,
xlim=c(1, ncol(mx)),
main=feature_names[1])
for (i in 1:nrow(mx)) {
y <- mx[i,]
points(x, y, col=col[i])
smoothingSpline = smooth.spline(x, y, spar=0.1)
xl <- seq(min(x), max(x), length=length(x)*10)
lines(predict(smoothingSpline, xl), col=col[i])
}
axis(1, at=1:length(signal_names), labels=signal_names, srt = 45, xpd=TRUE)
plot(0,type='n',
axes=T,
ann=T,
ylim=ylim,
xlim=c(1, ncol(mx)),
main=feature_names[1])
for (i in 1:nrow(mx)) {
y <- mx[i,]
points(x, y, col=col[i])
smoothingSpline = smooth.spline(x, y, spar=0.1)
xl <- seq(min(x), max(x), length=length(x)*10)
lines(predict(smoothingSpline, xl), col=col[i])
}
axis(1, at=1:length(signal_names[x]), labels=signal_names[x], srt = 45, xpd=TRUE)
features.box.plot <- function(indir=c("/home/suvar/Projects/007_ChIPseq_HU-SR/output/bdg/Et",
"/home/suvar/Projects/007_ChIPseq_HU-SR/output/bdg/IAA"),
outdir="/home/suvar/Desktop",
fdir="/home/suvar/Projects/Sources/Cs_genomic_features_v1",
chromsizes='sc',
lables = c("1.5h", "2h", "0'", "10'", "30'", "40'", , "50'", "60'", "70'", "80'", "90")
title="Average log2 difference of H4K16Ac vs 1.5h sample",
filename="All_features_box_plot",
notes="",
exclude_seq="chrM",
ylim=NULL)
{
seql <- MNuc::seqlevels.from.chrsizes(chromsizes=chromsizes)
### Import Features > GR
features <- list.files(path=fdir, pattern="*.csv", full.names=TRUE, recursive=FALSE)
feature_list <- lapply(features, function(f) {
gr <- makeGRangesFromDataFrame(read.table(f, sep="\t", header=TRUE, quote =""), keep.extra.columns=TRUE,
seqinfo=seql)
#seqlengths(gr) <- seql
gr <- dropSeqlevels(gr, value=exclude_seq, pruning.mode="coarse")
} )
feature_names <- lapply(features, function(f) { tools::file_path_sans_ext(basename(f)) })
print("All features imported as genomicranges")
### Import Signals > GR
print("Importing signals started")
signals <- list.files(path=indir, pattern="*.bdg.gz", full.names=TRUE, recursive=FALSE)
scores_list <- lapply(signals, function(x) {
signal <- sort(GenomeInfoDb::sortSeqlevels(import(x, format="bedGraph")))
# Set seqlevels to make a correct coverage across all chromosome lengths
seqlengths(signal) <- seql
signal <- dropSeqlevels(signal, value=exclude_seq, pruning.mode="coarse")
# Find coverage of GRange
GenomicRanges::coverage(signal, weight="score")
} )
print("Importing signals ended, scores list created without errors")
### Get Signal Names
signal_names <- sapply(strsplit(tools::file_path_sans_ext(basename(signals)), "_"), function(x) x[2])
### START PLOT
print("Plot started")
dir.create(file.path(outdir), recursive = TRUE)
pdf(paste(outdir, filename, ".pdf", sep=""), width=7, height=13, pointsize=5)
par(mfrow=c(6,3)) # how many diagrams on one plot?
par(mar=c(4,4,2,1.5)) # margins size
par(oma=c(4,1,4,1)) # outer margins in lines
col=c('darkslateblue', 'brown4')
invisible(lapply(seq_along(feature_list), function(idx) {
vec_data <- sapply(scores_list, function(sc) {
data <- GenomicRanges::binnedAverage(feature_list[[1]], sc, "avg_score")
m <- mean(data$avg_score)
})
if (is.null(ylim)) {
lim_min <- min(vec_data)
lim_max <- max(vec_data)
ylim = c(lim_min, lim_max)
}
mx <- matrix(vec_data, length(indir), byrow=TRUE)
x <- c(1:ncol(mx))
plot(0,type='n',
axes=T,
ann=T,
ylim=ylim,
xlim=c(1, ncol(mx)),
main=feature_names[1])
for (i in 1:nrow(mx)) {
y <- mx[i,]
points(x, y, col=col[i])
smoothingSpline = smooth.spline(x, y, spar=0.1)
xl <- seq(min(x), max(x), length=length(x)*10)
lines(predict(smoothingSpline, xl), col=col[i])
}
axis(1, at=1:length(signal_names[x]), labels=signal_names[x], srt = 45, xpd=TRUE)
}))
mtext(title, side=3, line=1, outer=TRUE, cex=1.5)
mtext(notes, side=1, line=1, outer=TRUE, adj=0)
mtext(Sys.Date(), side=1, line=1, outer=TRUE, adj=1)
dev.off()
}
plot(0,type='n',
axes=T,
ann=T,
ylim=ylim,
xlim=c(1, ncol(mx)),
main=feature_names[1])
for (i in 1:nrow(mx)) {
y <- mx[i,]
points(x, y, col=col[i])
smoothingSpline = smooth.spline(x, y, spar=0.1)
xl <- seq(min(x), max(x), length=length(x)*10)
lines(predict(smoothingSpline, xl), col=col[i])
}
axis(1, at=1:length(signal_names[x]), labels=signal_names[x], srt = 45, xpd=TRUE)
plot(0,type='n',
axes=T,
ann=T,
ylim=ylim,
xlim=c(1, ncol(mx)),
main=feature_names[1])
for (i in 1:nrow(mx)) {
y <- mx[i,]
points(x, y, col=col[i])
smoothingSpline = smooth.spline(x, y, spar=0.1)
xl <- seq(min(x), max(x), length=length(x)*10)
lines(predict(smoothingSpline, xl), col=col[i])
}
lables = c("1.5h", "2h", "0'", "10'", "30'", "40'", , "50'", "60'", "70'", "80'", "90")
lables = c("1.5h", "2h", "0'", "10'", "20'", "30'", "40'", "50'", "60'", "70'", "80'", "90")
lables = c("1.5h", "2h", "0'", "10'", "20'", "30'", "40'", "50'", "60'", "70'", "80'", "90")
### Get Signal Names
if (is.null(lables)) {
signal_names <- sapply(strsplit(tools::file_path_sans_ext(basename(signals)), "_"), function(x) x[2])
} else { signal_names <- lables}
signal_names
axis(1, at=1:length(signal_names[x]), labels=signal_names[x], srt = 45, xpd=TRUE)
plot(0,type='n',
axes=T,
xaxt="n"
ann=T,
ylim=ylim,
xlim=c(1, ncol(mx)),
main=feature_names[1])
plot(0,type='n',
axes=T,
xaxt="n",
ann=T,
ylim=ylim,
xlim=c(1, ncol(mx)),
main=feature_names[1])
for (i in 1:nrow(mx)) {
y <- mx[i,]
points(x, y, col=col[i])
smoothingSpline = smooth.spline(x, y, spar=0.1)
xl <- seq(min(x), max(x), length=length(x)*10)
lines(predict(smoothingSpline, xl), col=col[i])
}
axis(1, at=1:length(signal_names[x]), labels=signal_names[x], srt = 45, xpd=TRUE)
seql <- MNuc::seqlevels.from.chrsizes(chromsizes=chromsizes)
### Import Features > GR
features <- list.files(path=fdir, pattern="*.csv", full.names=TRUE, recursive=FALSE)
feature_list <- lapply(features, function(f) {
gr <- makeGRangesFromDataFrame(read.table(f, sep="\t", header=TRUE, quote =""), keep.extra.columns=TRUE,
seqinfo=seql)
#seqlengths(gr) <- seql
gr <- dropSeqlevels(gr, value=exclude_seq, pruning.mode="coarse")
} )
feature_names <- lapply(features, function(f) { tools::file_path_sans_ext(basename(f)) })
print("All features imported as genomicranges")
### Import Signals > GR
print("Importing signals started")
cat("All features imported as genomicranges")
### Import Signals > GR
cat("Importing signals started")
signals <- list.files(path=indir, pattern="*.bdg.gz", full.names=TRUE, recursive=FALSE)
scores_list <- lapply(signals, function(x) {
signal <- sort(GenomeInfoDb::sortSeqlevels(import(x, format="bedGraph")))
# Set seqlevels to make a correct coverage across all chromosome lengths
seqlengths(signal) <- seql
signal <- dropSeqlevels(signal, value=exclude_seq, pruning.mode="coarse")
# Find coverage of GRange
GenomicRanges::coverage(signal, weight="score")
} )
### Get Signal Names
if (is.null(lables)) {
signal_names <- sapply(strsplit(tools::file_path_sans_ext(basename(signals)), "_"), function(x) x[2])
} else { signal_names <- lables}
### START PLOT
cat("Plot started")
dir.create(file.path(outdir), recursive = TRUE)
pdf(paste(outdir, filename, ".pdf", sep=""), width=7, height=13, pointsize=5)
filename="All_features_box_plot"
pdf(paste(outdir, filename, ".pdf", sep=""), width=7, height=13, pointsize=5)
par(mfrow=c(6,3)) # how many diagrams on one plot?
par(mar=c(4,4,2,1.5)) # margins size
par(oma=c(4,1,4,1)) # outer margins in lines
col=c('darkslateblue', 'brown4')
invisible(lapply(seq_along(feature_list), function(idx) {
vec_data <- sapply(scores_list, function(sc) {
data <- GenomicRanges::binnedAverage(feature_list[[idx]], sc, "avg_score")
m <- mean(data$avg_score)
})
if (is.null(ylim)) {
lim_min <- min(vec_data)
lim_max <- max(vec_data)
ylim = c(lim_min, lim_max)
}
mx <- matrix(vec_data, length(indir), byrow=TRUE)
x <- c(1:ncol(mx))
plot(0,type='n',
axes=T,
xaxt="n",
ann=T,
ylim=ylim,
xlim=c(1, ncol(mx)),
main=feature_names[1])
for (i in 1:nrow(mx)) {
y <- mx[i,]
points(x, y, col=col[i])
smoothingSpline = smooth.spline(x, y, spar=0.1)
xl <- seq(min(x), max(x), length=length(x)*10)
lines(predict(smoothingSpline, xl), col=col[i])
}
axis(1, at=1:length(signal_names[x]), labels=signal_names[x], srt = 45, xpd=TRUE)
}))
mtext(title, side=3, line=1, outer=TRUE, cex=1.5)
mtext(Sys.Date(), side=1, line=1, outer=TRUE, adj=1)
mtext(title, side=3, line=1, outer=TRUE, cex=1.5)
title="Hello!"
mtext(title, side=3, line=1, outer=TRUE, cex=1.5)
dev.off()
features.box.plot <- function(indir=c("/home/suvar/Projects/007_ChIPseq_HU-SR/output/bdg/Et",
"/home/suvar/Projects/007_ChIPseq_HU-SR/output/bdg/IAA"),
outdir="/home/suvar/Desktop",
fdir="/home/suvar/Projects/Sources/Cs_genomic_features_v1",
chromsizes='sc',
lables = c("1.5h", "2h", "0'", "10'", "20'", "30'", "40'", "50'", "60'", "70'", "80'", "90")
title="Hello!",
filename="All_features_box_plot",
exclude_seq="chrM",
ylim=NULL)
{
seql <- MNuc::seqlevels.from.chrsizes(chromsizes=chromsizes)
### Import Features > GR
features <- list.files(path=fdir, pattern="*.csv", full.names=TRUE, recursive=FALSE)
feature_list <- lapply(features, function(f) {
gr <- makeGRangesFromDataFrame(read.table(f, sep="\t", header=TRUE, quote =""), keep.extra.columns=TRUE,
seqinfo=seql)
#seqlengths(gr) <- seql
gr <- dropSeqlevels(gr, value=exclude_seq, pruning.mode="coarse")
} )
feature_names <- lapply(features, function(f) { tools::file_path_sans_ext(basename(f)) })
cat("All features imported as genomicranges")
### Import Signals > GR
cat("Importing signals started")
signals <- list.files(path=indir, pattern="*.bdg.gz", full.names=TRUE, recursive=FALSE)
scores_list <- lapply(signals, function(x) {
signal <- sort(GenomeInfoDb::sortSeqlevels(import(x, format="bedGraph")))
# Set seqlevels to make a correct coverage across all chromosome lengths
seqlengths(signal) <- seql
signal <- dropSeqlevels(signal, value=exclude_seq, pruning.mode="coarse")
# Find coverage of GRange
GenomicRanges::coverage(signal, weight="score")
} )
cat("Importing signals ended, scores list created without errors")
### Get Signal Names
if (is.null(lables)) {
signal_names <- sapply(strsplit(tools::file_path_sans_ext(basename(signals)), "_"), function(x) x[2])
} else { signal_names <- lables}
### START PLOT
cat("Plot started")
dir.create(file.path(outdir), recursive = TRUE)
pdf(paste(outdir, filename, ".pdf", sep=""), width=7, height=13, pointsize=5)
par(mfrow=c(6,3)) # how many diagrams on one plot?
par(mar=c(4,4,2,1.5)) # margins size
par(oma=c(4,1,4,1)) # outer margins in lines
col=c('darkslateblue', 'brown4')
invisible(lapply(seq_along(feature_list), function(idx) {
vec_data <- sapply(scores_list, function(sc) {
data <- GenomicRanges::binnedAverage(feature_list[[idx]], sc, "avg_score")
m <- mean(data$avg_score)
})
if (is.null(ylim)) {
lim_min <- min(vec_data)
lim_max <- max(vec_data)
ylim = c(lim_min, lim_max)
}
mx <- matrix(vec_data, length(indir), byrow=TRUE)
x <- c(1:ncol(mx))
plot(0,type='n',
axes=T,
xaxt="n",
ann=T,
ylim=ylim,
xlim=c(1, ncol(mx)),
main=feature_names[1])
for (i in 1:nrow(mx)) {
y <- mx[i,]
points(x, y, col=col[i])
smoothingSpline = smooth.spline(x, y, spar=0.1)
xl <- seq(min(x), max(x), length=length(x)*10)
lines(predict(smoothingSpline, xl), col=col[i])
}
axis(1, at=1:length(signal_names[x]), labels=signal_names[x], srt = 45, xpd=TRUE)
}))
mtext(title, side=3, line=1, outer=TRUE, cex=1.5)
mtext(Sys.Date(), side=1, line=1, outer=TRUE, adj=1)
dev.off()
}
pdf(paste(outdir, filename, ".pdf", sep=""), width=7, height=13, pointsize=5)
par(mfrow=c(6,3)) # how many diagrams on one plot?
par(mar=c(4,4,2,1.5)) # margins size
par(oma=c(4,1,4,1)) # outer margins in lines
col=c('darkslateblue', 'brown4')
invisible(lapply(seq_along(feature_list), function(idx) {
vec_data <- sapply(scores_list, function(sc) {
data <- GenomicRanges::binnedAverage(feature_list[[idx]], sc, "avg_score")
m <- mean(data$avg_score)
})
lim_min <- min(vec_data)
lim_max <- max(vec_data)
ylim = c(lim_min, lim_max)
mx <- matrix(vec_data, length(indir), byrow=TRUE)
x <- c(1:ncol(mx))
plot(0,type='n',
axes=T,
xaxt="n",
ann=T,
ylim=ylim,
xlim=c(1, ncol(mx)),
main=feature_names[1])
for (i in 1:nrow(mx)) {
y <- mx[i,]
points(x, y, col=col[i])
smoothingSpline = smooth.spline(x, y, spar=0.1)
xl <- seq(min(x), max(x), length=length(x)*10)
lines(predict(smoothingSpline, xl), col=col[i])
}
axis(1, at=1:length(signal_names[x]), labels=signal_names[x], srt = 45, xpd=TRUE)
}))
mtext(title, side=3, line=1, outer=TRUE, cex=1.5)
mtext(Sys.Date(), side=1, line=1, outer=TRUE, adj=1)
dev.off()
outdir="/home/suvar/Desktop/"
pdf(paste(outdir, filename, ".pdf", sep=""), width=7, height=13, pointsize=5)
par(mfrow=c(6,3)) # how many diagrams on one plot?
par(mar=c(4,4,2,1.5)) # margins size
par(oma=c(4,1,4,1)) # outer margins in lines
col=c('darkslateblue', 'brown4')
invisible(lapply(seq_along(feature_list), function(idx) {
vec_data <- sapply(scores_list, function(sc) {
data <- GenomicRanges::binnedAverage(feature_list[[idx]], sc, "avg_score")
m <- mean(data$avg_score)
})
lim_min <- min(vec_data)
lim_max <- max(vec_data)
ylim = c(lim_min, lim_max)
mx <- matrix(vec_data, length(indir), byrow=TRUE)
x <- c(1:ncol(mx))
plot(0,type='n',
axes=T,
xaxt="n",
ann=T,
ylim=ylim,
xlim=c(1, ncol(mx)),
main=feature_names[idx])
for (i in 1:nrow(mx)) {
y <- mx[i,]
points(x, y, col=col[i])
smoothingSpline = smooth.spline(x, y, spar=0.1)
xl <- seq(min(x), max(x), length=length(x)*10)
lines(predict(smoothingSpline, xl), col=col[i])
}
axis(1, at=1:length(signal_names[x]), labels=signal_names[x], srt = 45, xpd=TRUE)
}))
mtext(title, side=3, line=1, outer=TRUE, cex=1.5)
mtext(Sys.Date(), side=1, line=1, outer=TRUE, adj=1)
dev.off()
